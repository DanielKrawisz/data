// Copyright (c) 2019-2023 Daniel Krawisz
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#ifndef DATA_MATH_NUMBER_ERATOSTHENES
#define DATA_MATH_NUMBER_ERATOSTHENES

#include <data/stack.hpp>
#include <data/set.hpp>
#include <data/priority_queue.hpp>
#include <data/math/number/prime.hpp>

namespace data::math::number {
    
    template <typename N>
    struct eratosthenes {
        // stack of primes generated by the sieve in reverse order.
        stack<prime<N>> Primes;

        eratosthenes ();

        // generate next prime.
        eratosthenes next () const;

        // create a sieve with the first n primes already generated.
        eratosthenes (N n);

        // generate next n primes.
        eratosthenes next (N n) const;
        
    private:
        N Next;
        
        struct entry {
            N Prime;
            N Multiple;
            
            bool operator <= (const entry &e) const {
                return Multiple <= e.Multiple;
            }
            
            entry increment () const {
                return {Prime, Multiple + Prime};
            }
        };
        
        using heap = priority_queue<entry>;
        heap Sieve;
        
        eratosthenes (stack<prime<N>> p, N m, heap sieve) : Primes {p}, Next {m}, Sieve {sieve} {}
        
        static heap insert_prime (heap sieve, N prime) {
            return sieve.insert (entry {prime, prime * 2});
        }; 
        
        eratosthenes step () const ;
        static bool test_next_prime (const N next, heap &q);
        
    };

    // an infinite list of primes.
    template <typename N>
    struct primes {
        prime<N> first () const;
        primes rest () const;

        primes (eratosthenes<N>);

        stack<prime<N>> Primes;
        eratosthenes<N> Eratosthenes;

        prime<N> operator [] (N n) {
            if (n == 0) return first ();
            return rest ()[n - 1];
        }

    private:
        primes (stack<prime<N>> p, eratosthenes<N> x);
    };

    template <typename N>
    eratosthenes<N>::eratosthenes () : Primes {}, Next {2}, Sieve {} {}

    template <typename N>
    eratosthenes<N>::eratosthenes (N n) : eratosthenes {eratosthenes {}.next (n)} {}

    template <typename N>
    eratosthenes<N> eratosthenes<N>::next (N n) const {
        N required = n + Primes.size ();
        eratosthenes e = *this;
        while (required > e.Primes.size ()) e = e.step ();
        return e;
    }

    template <typename N>
    eratosthenes<N> eratosthenes<N>::next () const {
        return next (1);
    }
    
    template <typename N>
    bool eratosthenes<N>::test_next_prime (const N next, heap &q) {
        if (q.empty ()) return true;
        N multiple;
        while (true) {
            multiple = q.first ().Multiple;
            if (next == multiple) return false;
            if (next < multiple) return true;
            q = q.rest ().insert (entry {q.first ().increment ()});
        } 
    }
    
    template <typename N>
    eratosthenes<N> eratosthenes<N>::step () const {
        heap q = Sieve;
        if (test_next_prime (Next, q)) return {Primes >> prime<N> {Next, prime<N>::certain}, Next + 1, insert_prime (q, Next)};
        else return {Primes, Next + 1, q};
    }

    template <typename N>
    prime<N> inline primes<N>::first () const {
        return Primes.first ();
    }

    template <typename N>
    primes<N> inline primes<N>::rest () const {
        if (data::size (Primes) > 1) return primes {data::rest (Primes), Eratosthenes};
        eratosthenes<N> n = Eratosthenes.next ();
        return primes {{data::first (n.Primes)}, n};
    }

    template <typename N>
    inline primes<N>::primes (const eratosthenes<N> x) : Primes {reverse (x.Primes)}, Eratosthenes {x} {
        if (data::size (Primes) == 0) *this = this->rest ();
    }

    template <typename N>
    inline primes<N>::primes (stack<prime<N>> p, eratosthenes<N> x) : Primes {p}, Eratosthenes {x} {}
    
}

#endif

